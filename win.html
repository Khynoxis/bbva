<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Ganaste – Pantalla de Felicitación</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; }
    body{
      display: grid;
      place-items: center;
      background: url("images/win.png") no-repeat center center / cover;
      color: #fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      cursor: pointer;
      user-select: none;
      overflow: hidden;
    }

    .wrap{
      display: grid;
      gap: clamp(10px, 2.6vh, 28px);
      justify-items: center;
      padding: 0 16px;
      text-align: center;
      max-width: min(92vw, 1100px);
    }

    /* Título con typewriter */
    #typewriter{
      font-weight: 800;
      line-height: 1.15;
      letter-spacing: .4px;
      font-size: clamp(56px, 6.4vw, 92px);
      text-shadow: 0 2px 12px rgba(0,0,0,.45);
      white-space: nowrap;
      border-right: 0.14em solid rgba(255,255,255,.75);
      overflow: hidden;
    }
    @keyframes caret {
      0%, 49% { border-color: rgba(255,255,255,.75); }
      50%, 100% { border-color: transparent; }
    }
    .caret { animation: caret .8s steps(1, end) infinite; }

    /* Subtítulo con animación distinta (fade-up + zoom) */
    #subtitle{
      margin-top: 100px;
      font-weight: 600;
      line-height: 1.25;
      letter-spacing: .3px;
      font-size: clamp(60px, 2.6vw, 34px);
      opacity: 0;
      transform: translateY(16px) scale(0.985);
      text-shadow: 0 2px 10px rgba(0,0,0,.35);
      will-change: transform, opacity;
    }
    @keyframes fadeUpIn {
      from { opacity: 0; transform: translateY(18px) scale(0.985); }
      to   { opacity: 1; transform: translateY(0) scale(1); }
    }
    .show-subtitle { animation: fadeUpIn .60s cubic-bezier(.22,.9,.19,1) forwards; }

    /* Canvas del confeti */
    #confetti {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 100;
    }

    @media (prefers-reduced-motion: reduce){
      #typewriter, .caret { animation: none !important; border-right: none !important; }
      .show-subtitle { animation: none !important; opacity: 1 !important; transform: none !important; }
    }
  </style>
</head>
<body>
  <canvas id="confetti" aria-hidden="true"></canvas>

  <div class="wrap" aria-live="polite">
    <div id="typewriter" aria-label="Título"> </div>
    <div id="subtitle" aria-label="Mensaje secundario">
      Superaste la trivia, <br> eres un verdadero conocedor del <br>Pago Automático
    </div>
  </div>

  <script>
  (function(){
    const NEXT_URL = "index.html";     // cámbialo si tu juego usa otro archivo
    const titleEl = document.getElementById('typewriter');
    const subtitleEl = document.getElementById('subtitle');

    /* =========================
       1) Typewriter principal
       ========================= */
    const titleText = "¡FELICIDADES!";
    const delay = 36; // ms por carácter
    let i = 0;

    function type(){
      if (i <= titleText.length){
        titleEl.textContent = titleText.slice(0, i);
        if (i === 0) titleEl.classList.add('caret');
        i++;
        setTimeout(type, delay);
      } else {
        titleEl.classList.remove('caret');
        subtitleEl.classList.add('show-subtitle');
        // Arranque automático del confeti
        startConfetti({ durationMs: 4500, dripHz: 14, burst: 120 });
      }
    }
    type();

    /* =========================
       2) Confeti realista desde ARRIBA, goteo continuo
       ========================= */
    const cnv = document.getElementById('confetti');
    const ctx = cnv.getContext('2d');

    // Soporte HiDPI
    let DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    function resize(){
      const cssW = window.innerWidth;
      const cssH = window.innerHeight;
      DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      cnv.width  = Math.floor(cssW * DPR);
      cnv.height = Math.floor(cssH * DPR);
      cnv.style.width  = cssW + 'px';
      cnv.style.height = cssH + 'px';
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0); // todas las coords en CSS px
    }
    window.addEventListener('resize', resize, {passive:true});
    resize();

    // Paleta vibrante (con un par metálicos claros)
    const COLORS = ["#FFD166","#06D6A0","#118AB2","#EF476F","#F7FFF7","#9B5DE5","#00F5D4","#FFE156","#FFCAD4"];

    // Estados
    let particles = [];
    let animId = null;
    let running = false;
    let t = 0;             // tiempo acumulado para viento
    let gust = 0;          // fuerza de ráfaga actual
    let gustTarget = 0;    // fuerza objetivo
    let gustPhase = 0;     // fase para variación

    function rand(a,b){ return Math.random()*(b-a)+a; }
    function rndInt(a,b){ return (Math.random()*(b-a+1)|0)+a; }
    function lerp(a,b,t){ return a+(b-a)*t; }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    // Spawner: goteo desde arriba, distribuido en columnas con jitter
    function spawnFromTop(n, layerBias=1){
      const W = window.innerWidth;
      for (let k=0; k<n; k++){
        const layer = Math.random(); // 0..1 (parallax)
        // bias: más probabilidad de capas medias para densidad agradable
        const depth = Math.pow(layer, layerBias);

        const x = rand(-40, W + 40);
        const y = rand(-120, -20);

        // Cada partícula es un "papel" con forma aleatoria
        const shape = (Math.random()<0.7) ? 'rect' : (Math.random()<0.5 ? 'tri' : 'circ');

        // Parallax: piezas grandes caen algo más rápido
        const sizeBase = lerp(6, 14, 1 - depth);
        const wRect = sizeBase * rand(0.9, 1.4);
        const hRect = sizeBase * rand(1.0, 1.8);

        const color = COLORS[rndInt(0, COLORS.length-1)];

        // física inicial
        const angle = rand(Math.PI/2 - 0.5, Math.PI/2 + 0.5); // hacia abajo casi vertical
        const speed = lerp(1.1, 2.6, 1 - depth) * rand(0.85, 1.15);
        const vx0 = Math.cos(angle) * speed;
        const vy0 = Math.sin(angle) * speed;

        particles.push({
          x, y,
          vx: vx0 + rand(-0.15, 0.15),
          vy: vy0 + rand(0.02, 0.22),
          g:  lerp(0.03, 0.085, 1 - depth),        // gravedad
          drag: lerp(0.986, 0.994, depth),         // más drag en fondo
          maxVy: lerp(2.0, 3.6, 1 - depth),
          swayAmp: lerp(0.2, 1.1, 1 - depth),      // vaivén
          swayFreq: rand(0.7, 1.8),
          rot: rand(0, Math.PI*2),
          vr: rand(-0.12, 0.12),
          flipT: rand(0, Math.PI*2),               // para flip (simulación 3D)
          flipSpeed: rand(0.05, 0.16),
          shade: rand(0.85, 1.08),                 // leve sombreado
          wRect, hRect, shape, color,
          alpha: 1,
          fade: rand(0.001, 0.0032)
        });
      }
    }

    function drawParticle(p){
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot);

      // flip (simula giro de papel)
      p.flipT += p.flipSpeed;
      const flip = Math.sin(p.flipT); // -1..1
      const flipScale = lerp(0.6, 1.0, Math.abs(flip)); // aplana cuando "gira"
      const shade = clamp(p.shade * lerp(0.85, 1.15, (flip+1)/2), 0.7, 1.2);

      ctx.globalAlpha = p.alpha;
      // sombreado muy sutil
      const fill = p.color;
      // aplicar un multiplicador simple al color (sombrado) sin parsear hex: usamos globalComposite para reforzar
      ctx.fillStyle = fill;

      switch(p.shape){
        case 'rect': {
          ctx.scale(1, flipScale);
          ctx.fillRect(-p.wRect/2, -p.hRect/2, p.wRect, p.hRect);
          break;
        }
        case 'tri': {
          ctx.scale(1, flipScale);
          const w = p.wRect, h = p.hRect;
          ctx.beginPath();
          ctx.moveTo(0, -h/2);
          ctx.lineTo(-w/2, h/2);
          ctx.lineTo(w/2, h/2);
          ctx.closePath();
          ctx.fill();
          break;
        }
        default: { // circ
          const r = (p.wRect + p.hRect) * 0.25;
          ctx.scale(1, flipScale);
          ctx.beginPath();
          ctx.arc(0, 0, r, 0, Math.PI*2);
          ctx.fill();
        }
      }

      // ligero glow con composite para “metalizar” algún color claro
      if (Math.random() < 0.05){
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = 0.08;
        ctx.fillRect(-p.wRect/2, -p.hRect/2, p.wRect, p.hRect);
        ctx.globalCompositeOperation = 'source-over';
      }

      ctx.restore();
    }

    function step(){
      t += 0.016; // ~60 fps

      // viento base ondulante
      const baseWind = Math.sin(t * 0.6) * 0.08 + Math.sin(t * 0.13) * 0.05;

      // ráfagas: variamos objetivo lentamente y lo interpolamos
      gustPhase += 0.004;
      if (Math.random() < 0.02) {
        // a veces queremos una ráfaga más marcada
        gustTarget = rand(-0.35, 0.35);
      } else {
        // normalmente, objetivo pequeño
        gustTarget = Math.sin(gustPhase) * 0.18;
      }
      gust = lerp(gust, gustTarget, 0.02);

      ctx.clearRect(0,0,cnv.width/DPR,cnv.height/DPR);

      for (let i = particles.length - 1; i >= 0; i--){
        const p = particles[i];

        // viento horizontal
        const wind = baseWind + gust;
        p.vx += wind * 0.02;

        // gravedad con tope
        p.vy = Math.min(p.vy + p.g, p.maxVy);

        // resistencia del aire
        p.vx *= p.drag;
        p.vy *= p.drag;

        // mover
        p.x += p.vx;
        p.y += p.vy;

        // rotación suave
        p.rot += p.vr;

        // desvanecido
        p.alpha -= p.fade;

        drawParticle(p);

        // kill offscreen
        const W = window.innerWidth, H = window.innerHeight;
        if (p.y > H + 80 || p.x < -120 || p.x > W + 120 || p.alpha <= 0){
          particles.splice(i, 1);
        }
      }

      if (running || particles.length > 0) {
        animId = requestAnimationFrame(step);
      } else {
        cancelAnimationFrame(animId);
        animId = null;
      }
    }

    // Goteo continuo durante "durationMs" + emisión inicial "burst"
    function startConfetti({ durationMs = 4000, dripHz = 12, burst = 120 } = {}){
      const prefersReduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      if (prefersReduce) return;

      running = true;
      const start = performance.now();
      const dripInterval = Math.max(40, 1000 / dripHz); // ms entre goteos
      let nextSpawn = start;

      // estallido inicial suave
      spawnFromTop(burst, 1.4);

      if (!animId) animId = requestAnimationFrame(step);

      function loop(){
        const now = performance.now();
        if (now - start < durationMs) {
          if (now >= nextSpawn) {
            // spawnea pequeñas tandas (simula columnas consecutivas)
            spawnFromTop(rndInt(6, 12), 1.2);
            nextSpawn = now + dripInterval + rand(-40, 80);
          }
          requestAnimationFrame(loop);
        } else {
          // terminar: dejar que se vayan las que quedan
          running = false;
        }
      }
      requestAnimationFrame(loop);
    }

    /* =========================
       3) Clicks: 1º celebra, 2º navega
       ========================= */
    let firstClickDone = false;
    function onFirstClick(){
      firstClickDone = true;
      startConfetti({ durationMs: 3500, dripHz: 14, burst: 90 });
      // siguiente click ya navega
      document.removeEventListener('click', onFirstClick, true);
      document.removeEventListener('touchend', onFirstClick, true);
      document.addEventListener('click', go, { once: true, capture: true });
      document.addEventListener('touchend', (ev) => { ev.preventDefault(); go(); }, { passive: false, once: true, capture: true });
    }
    document.addEventListener('click', onFirstClick, true);
    document.addEventListener('touchend', onFirstClick, true);

    /* =========================
       4) Redirección
       ========================= */
    let navigated = false;
    const go = () => {
      if (navigated) return;
      navigated = true;
      window.location.href = NEXT_URL;
    };

    // Auto-redirect en 6s (subí un poco para disfrutar el confeti lento)
    const tAuto = setTimeout(go, 6000);

    // Accesibilidad teclado (Enter/Espacio):
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        if (!firstClickDone){
          onFirstClick();
        } else {
          go();
        }
      }
    });

    // Si ya navegaste, cancela el timeout
    function cancelTimer(){ try { clearTimeout(tAuto); } catch(_){} }
    document.addEventListener('click', () => { if (navigated) cancelTimer(); }, {passive:true});
    document.addEventListener('keydown', () => { if (navigated) cancelTimer(); });

  })();
  </script>
</body>
</html>
